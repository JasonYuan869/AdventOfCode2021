use std::env;

#[cfg(test)]
mod tests {
    use crate::*;

    const INPUT_SIZE: usize = 6;
    static INPUT: [&str; INPUT_SIZE] = [
        "forward 5",
        "down 5",
        "forward 8",
        "up 3",
        "down 8",
        "forward 2",
    ];

    #[test]
    fn test_part1() {
        assert_eq!(part1(&INPUT, INPUT_SIZE), 150);
    }

    #[test]
    fn test_part2() {
        assert_eq!(part2(&INPUT, INPUT_SIZE), 900);
    }
}

// Include INPUT array and INPUT_SIZE constant generated by build script
include!(concat!(env!("OUT_DIR"), "/input.rs"));

fn part1(input: &[&str], _size: usize) -> i32 {
    let mut h_pos = 0_i32;
    let mut depth = 0_i32;
    for movement in input {
        let mut move_iter = movement.split_whitespace();
        let direction = move_iter.next().unwrap();
        let units = move_iter.next().unwrap().parse::<i32>().unwrap();
        match direction {
            "forward" => h_pos += units,
            "down" => depth += units,
            _ => depth -= units,
        }
    }
    h_pos * depth
}

fn part2(input: &[&str], _size: usize) -> i32 {
    let mut h_pos = 0_i32;
    let mut depth = 0_i32;
    let mut aim = 0_i32;
    for movement in input {
        let mut move_iter = movement.split_whitespace();
        let direction = move_iter.next().unwrap();
        let units = move_iter.next().unwrap().parse::<i32>().unwrap();
        match direction {
            "forward" => {
                h_pos += units;
                depth += aim * units;
            },
            "down" => aim += units,
            _ => aim -= units,
        }
    }
    h_pos * depth
}

fn main() {
    println!("Part 1: {}", part1(&INPUT, INPUT_SIZE));
    println!("Part 2: {}", part2(&INPUT, INPUT_SIZE));
}
